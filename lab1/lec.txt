лекция 1

каждый поток имеет свою структуру task, но в отличие от процессов,
потоки имеют одно и то же адресное пространство (картинку держи в голове)
в таких структурах task, есть указатель на адресное пространство, сделано это для того
чтобы при переключении между потоков не перезаписывать кэш таблицы трансляции.
При трансляции адресов из АП в оперативку процессор тратит много времени, для решения этой проблемы
существует кэш в процессоре для этого дела, но при переключении между процессами, ему нужно снова пересчитать
таблицу трансляции. Ну и потоки имеют общее адресное пространство, от этого пересчитывать ничего не надо.

потоки бывают ядерные(делегируются ядром OS) и пользовательские (работают только в userspace, переключение между ними
очень быстрое)

=====================================

лекция 2
при создании своего потока с помощью clone можно адресное пространство делать общим 
с помощью аттрибута CLONE_VM, тогда с структурах процессов будет указатель на адресное 
общее адресное пространство, если делать без флага клонвм, то в каждой структуре будет свое
адресное пространство

тут еще рассказывали про расшаривание области памяти на файл, вспомнили про механизм copyOnWrite,
только я забыл откуда на файл существуют разные указатели, даже если мы закрыли один дескриптор,
то кто еще ссылается на файл??

clone_vm разделяет ресурсы процесса, файлы - это тоже ресурс, со все вытекающем
при клонировании с clone_vm, у нас и массив с файловыми дескрипторами тоже одинаковый
а, для этого есть другой флаг - clone_files, если без него, снова же, то при закрытии 
файла в одном потоке, этот поток не сможет работать с файлом, а другой поток сможет

как раз сейчас вопрос про разные пиды процессов и потоков, для этого тоже есть флаг в clone

а еще все это было про линуксовые "потоки", а не позиксные

=====================================

лекция 3

в индентификаторе потока может быть не числа а структура, или другое что-то, поэтому
сравнивать их нужно с помощью функции, как классы в java

когда завершается процесс, тогда и завершаются все потоки созданные в этом процессе

=====================================

лекция 4 пользовательские потоки

мультиплексирование - ???

в специальную струкуру сохранит текущее состояние процесса
getcontext(&thread->before_start_routine);

это нужно для mythread_cancel

if (thread0>canceled) {
    setcontext(&(thread->before_start_routine));
}
сохраняем контекст
а после восстанавливаем контекст если у нас функция canceled


void mythread_testcancel(void) {
    ucont3xt_t 
    __mythread

    getcontext(&uctx);

    thread = gtid;

    if (thread->canceled) {
        setcontex()
    }
}

=====================================

лекция 5 сигналы в потоках

по описанию рутмана, сигналы это охуеть какая ультимативная штука, 
способная обходить блокировки процесса, различные состояния ядра и вообще
доставит то самое число до кого угодно, когда угодно

ресурсы связанные с сигналами так же разделяются между потоками

есть три битовые маски в структуре процесса, каждый бит - номер сигнала:
pending - сигналы, которые нужно доставить процессу
ignore - сигналы, которые надо проигнорить (не обрабатываем сигнал)
blocked - попадет в ожидающий сигнал, но процесс доставки не запуститься, 
    пока сигнал не разблокируется

в случае с потоками эти три битовые маски существуют по отдельности для каждого,
но обработчики сигнала и управляющая структура для сигналов
одна на весь процесс

ну тут все довольно потно, потому что есть 1000+ вариантов, 
когда откуда и как начнется обработка сигнала, начиная с того, 
что процессор находится в runnable или sleep состоянии,
но в любом случае происходит проверка бита в битовой маске

после попадания в функцию обработчика сигнала, которая находится в процессе,
но непонятно, куда после завершения обработчика двигаться дальше, 
а двигаться надо обратно в ядро, вдруг нам надо обработать еще один сигнал,
а еще надо вернуться обратно в исполняющую функцию восстанавливая контекст

в обработчике находятся адрес функции sigreturn , которая является сисколом
и переносит выполнение процесс в ядро, после этого можно восстановить контекст процесса,
сам контекст хранится в функции обраточика, который хуй пойми как там оказывается,

tgkill отправляет сигнал в отдельный поток


















