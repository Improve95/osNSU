запомнить как происходит переход из состояния
run runnable sleep когда мьютекс блокируется и разблокируется  

как варианта, на примере pipe:
когда мы исполняем pipe, мы знаем какие процесса ждут появления данных
вы пайпе, когда данные появляются, то мы переводим процессы из состояния
sleep в состояние run

но на самом деле там есть очередь из процессов ожидающих данных или
чего бы то ни было

Мьютекс использует механизм блокировки, т. е. процесс который хочет использовать ресурс, блокирует его, 
и после использования освобождает. С другой стороны, семафор использует механизм сигнализации, 
где методы wait() и signal() используются, чтобы показать, освободил ли процесс ресурс или занял его.

● Мьютекс это объект, а семафор это целочисленная переменная.

● Для работы с семафорами у нас есть функции wait() и signal(). Но при работе с мьютексом таких функций нет.

● Объект мьютекса позволяет многим потокам обращаться к одному и тому же общему ресурсу, 
но в любой момент времени доступ имеет только один поток. С другой стороны, 
семафор позволяет нескольким потокам использовать одновременно ограниченный объем ресурса определенного вида, 
пока этот ресурс не исчерпается.

● С мьютексом блокировку и освобождение ресурса должен сделать один и тот же процесс. Но значение переменной семафора 
может быть изменено любым процессом, которому нужен какой-то ресурс, но это изменение всегда атомарное, 
т. е. в любой момент времени изменить переменную семафора может только один процесс.

спинлок - поток крутиться в цикле, пока другой поток, который захватил ресурс не отпустит его

мьютекс - поток уходит в состояние sleep, после подъема снова проверяет ресура на доступ

условная переменная - точь в точь идеология, как с критическими секциями в java - поток засыпает на 
захваченном ресурсе, пока его не разбудит другой поток, после он должен проверить условие, по которому заснул -
все как в synchonized блока java
broadcast и signal - это идеологические прародители с таким же функционалом, как и notify и notifyAll соответственно

семафоры - поток блокируется, если переменная равна нулю, когда захватывает - уменьшает на 1, когда отпускает -
увеличивает на единицу, много потоков могут иметь одновременный доступ ко многим ресурсам